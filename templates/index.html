// Interface Management
      let availableInterfaces = [];
      let currentInterface = null;
      let isWindows = false;

      // Modal management
      function showInterfaceModal() {
        document.getElementById('interfaceModal').classList.remove('hidden');
        loadInterfaces();
      }

      function hideInterfaceModal() {
        document.getElementById('interfaceModal').classList.add('hidden');
      }

      // Loa<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Enhanced Packet Sniffer Dashboard</title>

    <!-- TailwindCSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- Leaflet -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- D3.js for network topology -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>

    <style>
      body {
        background-color: #0f172a;
        color: #e6eef8;
      }
      .card {
        background-color: #1e293b;
        border-radius: 1rem;
        padding: 1rem;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
      }
      .small {
        font-size: 0.85rem;
        color: #94a3b8;
      }
      .digital-counter {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono",
          "Courier New", monospace;
        letter-spacing: 0.02em;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.02),
          rgba(0, 0, 0, 0.02)
        );
        padding: 0.25rem 0.5rem;
        border-radius: 0.25rem;
        display: inline-block;
      }
      .badge {
        padding: 0.15rem 0.5rem;
        border-radius: 0.25rem;
        font-size: 0.7rem;
        font-weight: 600;
      }
      .tooltip-custom {
        background-color: #1e293b;
        color: #e6eef8;
        border-radius: 0.25rem;
        padding: 0.2rem 0.5rem;
        font-size: 0.75rem;
      }
      .custom-scroll::-webkit-scrollbar {
        width: 8px;
        background: #1e293b;
        border-radius: 8px;
      }
      .custom-scroll::-webkit-scrollbar-thumb {
        background: #334155;
        border-radius: 8px;
      }
      .custom-scroll::-webkit-scrollbar-thumb:hover {
        background: #475569;
      }
      .custom-scroll {
        scrollbar-width: thin;
        scrollbar-color: #334155 #1e293b;
      }
      .network-node {
        cursor: pointer;
        stroke-width: 2px;
        stroke: #60a5fa;
      }
      .network-link {
        stroke: #374151;
        stroke-width: 1px;
        opacity: 0.6;
      }
      .network-text {
        font-size: 10px;
        fill: #e6eef8;
        text-anchor: middle;
        pointer-events: none;
      }
      .flow-item {
        background: rgba(96, 165, 250, 0.1);
        border-left: 3px solid #60a5fa;
        margin-bottom: 0.5rem;
        padding: 0.5rem;
        border-radius: 0.25rem;
      }
      .packet-item {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
        font-size: 0.75rem;
        padding: 0.25rem;
        margin-bottom: 0.25rem;
        border-radius: 0.25rem;
        border-left: 2px solid #4ade80;
      }
      .packet-sent {
        border-left-color: #f97316;
        background-color: rgba(249, 115, 22, 0.1);
      }
      .packet-received {
        border-left-color: #4ade80;
        background-color: rgba(74, 222, 128, 0.1);
      }
    </style>
  </head>
  <body class="p-6">
    <div class="max-w-7xl mx-auto flex flex-col space-y-6">
      <!-- Header -->
      <header
        class="flex flex-col md:flex-row justify-between items-start md:items-center"
      >
        <h1 class="text-2xl md:text-3xl font-bold mb-2 md:mb-0">
          üîç Enhanced Network Monitor
        </h1>
        <div class="flex items-center space-x-4">
          <button id="interfaceBtn" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded text-sm font-medium">
            Select Interface
          </button>
          <div class="small text-gray-400">Real-time packet analysis</div>
        </div>
      </header>

      <!-- Interface Selection Modal -->
      <div id="interfaceModal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50">
        <div class="flex items-center justify-center min-h-screen p-4">
          <div class="bg-slate-800 rounded-lg p-6 max-w-2xl w-full max-h-96 overflow-y-auto">
            <h3 class="text-xl font-bold mb-4">Select Network Interface</h3>
            <div id="interfaceList" class="space-y-2 mb-4">
              <!-- Interface list will be populated here -->
            </div>
            <div class="flex justify-between">
              <button id="windowsFixBtn" class="bg-yellow-600 hover:bg-yellow-700 px-4 py-2 rounded text-sm hidden">
                Fix Windows Firewall
              </button>
              <div class="flex space-x-2">
                <button id="testAllBtn" class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded text-sm">
                  Test All
                </button>
                <button id="closeModalBtn" class="bg-gray-600 hover:bg-gray-700 px-4 py-2 rounded text-sm">
                  Close
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Status and Alerts Bar -->
      <div class="bg-slate-800 rounded-lg p-4 mb-4">
        <div class="flex flex-wrap items-center justify-between gap-4">
          <div class="flex items-center space-x-6">
            <div class="flex items-center space-x-2">
              <div id="captureStatus" class="w-3 h-3 bg-gray-500 rounded-full"></div>
              <span class="text-sm">Capture: <span id="captureStatusText">Unknown</span></span>
            </div>
            <div class="text-sm">
              Interface: <span id="currentInterface" class="font-mono bg-slate-700 px-2 py-1 rounded">None</span>
            </div>
            <div class="text-sm">
              Packets: <span id="captureCount" class="font-mono">0</span>
            </div>
          </div>
          <div class="text-xs text-gray-400" id="lastUpdate">
            Last update: Never
          </div>
        </div>
      </div>

      <!-- Enhanced Stats Cards -->
      <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
        <div class="card">
          <div class="flex justify-between items-center">
            <div class="small">üì¶ Total Packets</div>
            <span class="badge bg-blue-600">Live</span>
          </div>
          <div id="totalPackets" class="text-3xl font-semibold mt-2">0</div>
          <div class="small mt-2">
            üîó Connections: <span id="activeConnections">0</span>
          </div>
        </div>

        <div class="card">
          <div class="flex justify-between items-center">
            <div class="small">üìä Packet Flow</div>
            <span class="badge bg-green-600">Direction</span>
          </div>
          <div class="mt-2">
            <div class="flex justify-between text-sm">
              <span>üì§ Sent: <span id="packetsSent" class="font-mono">0</span></span>
              <span>üì• Received: <span id="packetsReceived" class="font-mono">0</span></span>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="flex justify-between items-center">
            <div class="small">‚ö° Bandwidth</div>
            <span class="badge bg-purple-600">Real-time</span>
          </div>
          <div class="w-full h-20">
            <canvas id="bandwidthChart" class="w-full h-full"></canvas>
          </div>
        </div>

        <div class="card">
          <div class="flex justify-between items-center">
            <div class="small">üö® Alerts</div>
            <span class="badge bg-red-600">Critical</span>
          </div>
          <ul
            id="alertsList"
            class="mt-2 text-xs overflow-y-auto max-h-20 custom-scroll"
          ></ul>
        </div>
      </div>

      <!-- Application and Protocol Analysis -->
      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        <div class="card">
          <div class="small mb-2">üåê Application Protocols</div>
          <div class="w-full h-48">
            <canvas id="appProtocolChart" class="w-full h-full"></canvas>
          </div>
        </div>

        <div class="card">
          <div class="small mb-2">üì± App Bandwidth Usage</div>
          <div class="w-full h-48">
            <canvas id="appBandwidthChart" class="w-full h-full"></canvas>
          </div>
        </div>

        <div class="card">
          <div class="small mb-2">üîå Network Protocols</div>
          <div class="w-full h-48">
            <canvas id="protocolChart" class="w-full h-full"></canvas>
          </div>
        </div>
      </div>

      <!-- Traffic Flow and Topology -->
      <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
        <div class="card">
          <div class="small mb-2">üîÑ Traffic Flows (Top Connections)</div>
          <div
            id="trafficFlows"
            class="h-64 overflow-y-auto custom-scroll"
          ></div>
        </div>

        <div class="card">
          <div class="small mb-2">üï∏Ô∏è Network Topology</div>
          <div id="networkTopology" class="h-64 bg-slate-900 rounded border relative overflow-hidden">
            <div id="topologyEmpty" class="absolute inset-0 flex items-center justify-center text-sm text-gray-400">
              Building network map...
            </div>
          </div>
        </div>
      </div>

      <!-- Detailed Analysis -->
      <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div class="card">
          <div class="small mb-2">üéØ Top Active IPs</div>
          <div class="w-full h-56">
            <canvas id="ipChart" class="w-full h-full"></canvas>
          </div>
        </div>

        <div class="card">
          <div class="small mb-2">üîå Port Activity</div>
          <div class="w-full h-56">
            <canvas id="portChart" class="w-full h-full"></canvas>
          </div>
        </div>
      </div>

      <!-- Packet Details and Geographic Map -->
      <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
        <div class="card">
          <div class="small mb-2">üåç Geographic Distribution</div>
          <div id="map" class="relative h-80 rounded-lg">
            <div
              id="mapEmpty"
              class="absolute inset-0 flex items-center justify-center text-sm text-gray-300 bg-black/30 rounded-lg pointer-events-none"
              style="display: none"
            >
              No geographic data available
            </div>
          </div>
        </div>

        <div class="card">
          <div class="small mb-2">üìã Live Packet Stream</div>
          <div
            id="packetDetails"
            class="h-80 overflow-y-auto custom-scroll text-xs"
          ></div>
        </div>
      </div>

      <!-- Packet Size and Logs -->
      <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
        <div class="card">
          <div class="small mb-2">üìè Packet Size Distribution</div>
          <div class="w-full h-48">
            <canvas id="sizeChart" class="w-full h-full"></canvas>
          </div>
        </div>

        <div class="card">
          <div class="small mb-2">üìú System Logs</div>
          <ul
            id="logsList"
            class="text-xs h-48 overflow-auto custom-scroll"
          ></ul>
        </div>
      </div>
    </div>

    <script>
      // Chart variables
      let protocolChart, ipChart, portChart, sizeChart, bandwidthChart;
      let appProtocolChart, appBandwidthChart;
      let _bandwidthInitialized = false;
      let networkSimulation;

      // Color palettes
      const colorPalette = [
        "#60a5fa", "#34d399", "#f97316", "#ef4444", "#a78bfa", 
        "#f59e0b", "#06b6d4", "#fb7185", "#10b981", "#8b5cf6"
      ];

      // Format number with commas
      function formatNumber(n) {
        return n.toLocaleString();
      }

      // Format bytes
      function formatBytes(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
      }

      // Mechanical counter animation
      function mechanicalCounter(el, target, duration = 1400, fps = 12) {
        if (!el) return;
        const startVal = parseInt(
          el.dataset.current || el.innerText.replace(/[^0-9]/g, "") || "0",
          10
        );
        target = parseInt(target || 0, 10);
        if (isNaN(startVal) || isNaN(target) || startVal === target) {
          el.innerText = formatNumber(target);
          el.dataset.current = String(target);
          return;
        }

        if (el._mechInterval) {
          clearInterval(el._mechInterval);
          el._mechInterval = null;
        }

        const steps = Math.max(3, Math.round((duration / 1000) * fps));
        const stepDelay = Math.round(duration / steps);
        const diff = target - startVal;
        let step = 0;

        el._mechInterval = setInterval(() => {
          step++;
          const t = step / steps;
          const eased = Math.pow(t, 1.12);
          const val = Math.round(startVal + diff * eased);
          el.innerText = formatNumber(val);
          el.dataset.current = String(val);
          el.classList.add("opacity-95");
          setTimeout(() => el.classList.remove("opacity-95"), 80);
          if (step >= steps) {
            clearInterval(el._mechInterval);
            el._mechInterval = null;
            el.innerText = formatNumber(target);
            el.dataset.current = String(target);
          }
        }, stepDelay);
      }

      // Create/Update Charts
      function createCharts(data) {
        // Destroy existing charts
        [protocolChart, ipChart, portChart, sizeChart, bandwidthChart, 
         appProtocolChart, appBandwidthChart].forEach(chart => {
          if (chart) {
            try { chart.destroy(); } catch(e) {}
          }
        });

        // Application Protocol Chart
        const appProtoLabels = data && data.app_protocols ? Object.keys(data.app_protocols) : [];
        const appProtoData = data && data.app_protocols ? Object.values(data.app_protocols) : [];
        appProtocolChart = new Chart(document.getElementById("appProtocolChart"), {
          type: "doughnut",
          data: {
            labels: appProtoLabels,
            datasets: [{
              data: appProtoData,
              backgroundColor: colorPalette.slice(0, appProtoLabels.length),
              borderColor: colorPalette.slice(0, appProtoLabels.length).map(() => "#0f172a"),
              borderWidth: 1,
            }],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { labels: { color: "#e6eef8", font: { size: 10 } } },
              tooltip: {
                backgroundColor: "#1e293b",
                titleColor: "#e6eef8",
                bodyColor: "#e6eef8",
              },
            },
          },
        });

        // Application Bandwidth Chart
        const appBwData = data && data.app_bandwidth ? data.app_bandwidth : {};
        const appNames = Object.keys(appBwData).slice(0, 8);
        const appBwValues = appNames.map(name => appBwData[name].total);
        
        appBandwidthChart = new Chart(document.getElementById("appBandwidthChart"), {
          type: "bar",
          data: {
            labels: appNames.map(name => name.length > 15 ? name.substring(0, 12) + '...' : name),
            datasets: [{
              label: "Total Bytes",
              data: appBwValues,
              backgroundColor: colorPalette[2],
              borderColor: colorPalette[2],
              borderWidth: 1
            }],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y',
            plugins: {
              legend: { labels: { color: "#e6eef8", font: { size: 10 } } },
              tooltip: {
                backgroundColor: "#1e293b",
                titleColor: "#e6eef8",
                bodyColor: "#e6eef8",
                callbacks: {
                  label: (context) => `${context.dataset.label}: ${formatBytes(context.raw)}`
                }
              },
            },
            scales: {
              x: { ticks: { color: "#e6eef8", font: { size: 9 } } },
              y: { ticks: { color: "#e6eef8", font: { size: 9 } } },
            },
          },
        });

        // Network Protocol Chart
        const protoLabels = data && data.protocols ? Object.keys(data.protocols) : [];
        const protoData = data && data.protocols ? Object.values(data.protocols) : [];
        protocolChart = new Chart(document.getElementById("protocolChart"), {
          type: "doughnut",
          data: {
            labels: protoLabels,
            datasets: [{
              data: protoData,
              backgroundColor: colorPalette.slice(0, protoLabels.length),
              borderColor: colorPalette.slice(0, protoLabels.length).map(() => "#0f172a"),
              borderWidth: 1,
            }],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { labels: { color: "#e6eef8", font: { size: 10 } } },
              tooltip: {
                backgroundColor: "#1e293b",
                titleColor: "#e6eef8",
                bodyColor: "#e6eef8",
              },
            },
          },
        });

        // IP Chart
        const ipLabels = data && data.top_ips ? data.top_ips.map(x => x[0] + " (" + x[1] + ")") : [];
        const ipData = data && data.top_ips ? data.top_ips.map(x => x[1]) : [];
        ipChart = new Chart(document.getElementById("ipChart"), {
          type: "bar",
          data: {
            labels: ipLabels,
            datasets: [{ 
              label: "Packets", 
              data: ipData,
              backgroundColor: colorPalette[0],
              borderColor: colorPalette[0]
            }],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: "y",
            plugins: {
              legend: { labels: { color: "#e6eef8" } },
              tooltip: {
                backgroundColor: "#1e293b",
                titleColor: "#e6eef8",
                bodyColor: "#e6eef8",
              },
            },
            scales: {
              x: { ticks: { color: "#e6eef8" } },
              y: { ticks: { color: "#e6eef8", font: { size: 9 } } },
            },
          },
        });

        // Port Chart
        const portLabels = data && data.top_ports ? data.top_ports.map(x => x[0]) : [];
        const portData = data && data.top_ports ? data.top_ports.map(x => x[1]) : [];
        portChart = new Chart(document.getElementById("portChart"), {
          type: "bar",
          data: {
            labels: portLabels,
            datasets: [{ 
              label: "Hits", 
              data: portData,
              backgroundColor: colorPalette[1],
              borderColor: colorPalette[1]
            }],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { labels: { color: "#e6eef8" } },
              tooltip: {
                backgroundColor: "#1e293b",
                titleColor: "#e6eef8",
                bodyColor: "#e6eef8",
              },
            },
            scales: {
              x: { ticks: { color: "#e6eef8" } },
              y: { ticks: { color: "#e6eef8" }, beginAtZero: true },
            },
          },
        });

        // Size Chart
        const sizeLabels = data && data.packet_sizes ? data.packet_sizes.map(x => x[0]) : [];
        const sizeData = data && data.packet_sizes ? data.packet_sizes.map(x => x[1]) : [];
        sizeChart = new Chart(document.getElementById("sizeChart"), {
          type: "bar",
          data: {
            labels: sizeLabels,
            datasets: [{ 
              label: "Count", 
              data: sizeData,
              backgroundColor: colorPalette[3],
              borderColor: colorPalette[3]
            }],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { labels: { color: "#e6eef8" } },
              tooltip: {
                backgroundColor: "#1e293b",
                titleColor: "#e6eef8",
                bodyColor: "#e6eef8",
              },
            },
            scales: {
              x: { ticks: { color: "#e6eef8" } },
              y: { ticks: { color: "#e6eef8" }, beginAtZero: true },
            },
          },
        });

        // Bandwidth Chart
        const bw = data && data.bandwidth ? data.bandwidth.slice() : [];
        bandwidthChart = new Chart(document.getElementById("bandwidthChart"), {
          type: "line",
          data: {
            labels: bw.map((_, i) => i - bw.length + "s"),
            datasets: [{
              label: "Bytes/sec",
              data: bw,
              fill: true,
              tension: 0.25,
              backgroundColor: "rgba(96,165,250,0.15)",
              borderColor: "#60a5fa",
            }],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: { intersect: false, mode: "index" },
            elements: { point: { radius: 0 } },
            plugins: {
              legend: { display: false },
              tooltip: {
                backgroundColor: "#1e293b",
                titleColor: "#e6eef8",
                bodyColor: "#e6eef8",
                callbacks: {
                  label: (context) => `${formatBytes(context.raw)}/sec`
                }
              },
            },
            scales: {
              x: {
                display: false,
                grid: { color: "rgba(230,238,248,0.03)" },
              },
              y: {
                display: false,
                grid: { color: "rgba(230,238,248,0.03)" },
              },
            },
          },
        });
      }

      // Network Topology Visualization
      function updateNetworkTopology(topologyData) {
        const container = document.getElementById("networkTopology");
        const emptyMsg = document.getElementById("topologyEmpty");
        
        // Clear previous visualization
        d3.select(container).select("svg").remove();
        
        if (!topologyData || topologyData.length === 0) {
          emptyMsg.style.display = "";
          return;
        }
        
        emptyMsg.style.display = "none";
        
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        const svg = d3.select(container)
          .append("svg")
          .attr("width", width)
          .attr("height", height);

        // Extract nodes and links
        const nodes = Array.from(new Set(
          topologyData.flatMap(d => [d.source, d.target])
        )).map(id => ({ id, group: id.startsWith("192.168.") ? 1 : 2 }));

        const links = topologyData.map(d => ({ source: d.source, target: d.target }));

        // Create force simulation
        const simulation = d3.forceSimulation(nodes)
          .force("link", d3.forceLink(links).id(d => d.id).distance(50))
          .force("charge", d3.forceManyBody().strength(-100))
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force("collision", d3.forceCollide().radius(15));

        // Add links
        const link = svg.append("g")
          .selectAll("line")
          .data(links)
          .join("line")
          .attr("class", "network-link");

        // Add nodes
        const node = svg.append("g")
          .selectAll("circle")
          .data(nodes)
          .join("circle")
          .attr("class", "network-node")
          .attr("r", 8)
          .attr("fill", d => d.group === 1 ? "#34d399" : "#60a5fa")
          .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

        // Add labels
        const label = svg.append("g")
          .selectAll("text")
          .data(nodes)
          .join("text")
          .attr("class", "network-text")
          .text(d => d.id.split('.').slice(-1)[0]) // Show only last octet
          .attr("dy", -12);

        // Tooltip
        node.append("title")
          .text(d => `IP: ${d.id}\nType: ${d.group === 1 ? 'Local' : 'External'}`);

        simulation.on("tick", () => {
          link
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);

          node
            .attr("cx", d => d.x)
            .attr("cy", d => d.y);

          label
            .attr("x", d => d.x)
            .attr("y", d => d.y);
        });

        function dragstarted(event, d) {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          d.fx = d.x;
          d.fy = d.y;
        }

        function dragged(event, d) {
          d.fx = event.x;
          d.fy = event.y;
        }

        function dragended(event, d) {
          if (!event.active) simulation.alphaTarget(0);
          d.fx = null;
          d.fy = null;
        }

        networkSimulation = simulation;
      }

      // Traffic Flows Display
      function updateTrafficFlows(flows) {
        const container = document.getElementById("trafficFlows");
        container.innerHTML = "";

        if (!flows || flows.length === 0) {
          container.innerHTML = '<div class="text-gray-400 text-center py-4">No traffic flows detected</div>';
          return;
        }

        flows.slice(0, 10).forEach(([flow, packets, bytes]) => {
          const [src, dst] = flow.split(':');
          const flowDiv = document.createElement('div');
          flowDiv.className = 'flow-item';
          flowDiv.innerHTML = `
            <div class="flex justify-between items-center mb-1">
              <div class="font-mono text-xs">
                <span class="text-orange-400">${src}</span> ‚Üí 
                <span class="text-green-400">${dst}</span>
              </div>
              <div class="text-xs text-gray-400">${formatBytes(bytes)}</div>
            </div>
            <div class="flex justify-between text-xs text-gray-300">
              <span>üì¶ ${packets} packets</span>
              <span>‚ö° ${(bytes/packets).toFixed(0)} B/pkt avg</span>
            </div>
          `;
          container.appendChild(flowDiv);
        });
      }

      // Packet Details Display
      function updatePacketDetails(packets) {
        const container = document.getElementById("packetDetails");
        container.innerHTML = "";

        if (!packets || packets.length === 0) {
          container.innerHTML = '<div class="text-gray-400 text-center py-4">No packet data available</div>';
          return;
        }

        packets.slice(0, 50).forEach(pkt => {
          const time = new Date(pkt.timestamp * 1000).toLocaleTimeString();
          const pktDiv = document.createElement('div');
          pktDiv.className = `packet-item ${pkt.direction === 'sent' ? 'packet-sent' : 'packet-received'}`;
          
          const dirIcon = pkt.direction === 'sent' ? 'üì§' : 'üì•';
          const processInfo = pkt.process ? ` [${pkt.process}]` : '';
          
          pktDiv.innerHTML = `
            <div class="flex justify-between items-start">
              <div class="flex-1 min-w-0">
                <div class="flex items-center space-x-1 text-xs">
                  <span>${dirIcon}</span>
                  <span class="text-gray-300">${time}</span>
                  <span class="text-blue-300">${pkt.protocol}</span>
                  ${pkt.app_protocol !== 'Unknown' ? `<span class="text-purple-300">${pkt.app_protocol}</span>` : ''}
                </div>
                <div class="text-xs mt-1 truncate">
                  <span class="text-orange-300">${pkt.src}</span>${pkt.sport ? `:${pkt.sport}` : ''} ‚Üí 
                  <span class="text-green-300">${pkt.dst}</span>${pkt.dport ? `:${pkt.dport}` : ''}
                  ${processInfo}
                </div>
              </div>
              <div class="text-xs text-gray-400 ml-2">${pkt.size}B</div>
            </div>
          `;
          container.appendChild(pktDiv);
        });
        
        // Auto-scroll to top for new packets
        container.scrollTop = 0;
      }

      // Map functionality
      let map = L.map("map").setView([20, 0], 2);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
      }).addTo(map);

      let markers = [];
      function updateMap(points) {
        try {
          map.invalidateSize();
          markers.forEach(m => map.removeLayer(m));
          markers = [];

          (points || []).forEach(p => {
            if (p && p.lat != null && p.lon != null) {
              const lat = parseFloat(p.lat);
              const lon = parseFloat(p.lon);
              if (Number.isFinite(lat) && Number.isFinite(lon)) {
                const marker = L.marker([lat, lon])
                  .addTo(map)
                  .bindPopup(
                    `<strong>${p.ip}</strong><br>${p.country || ""} ${p.city || ""}<br>Packets: ${p.count}`
                  );
                markers.push(marker);
              }
            }
          });

          const empty = document.getElementById("mapEmpty");
          if (!markers.length) {
            if (empty) empty.style.display = "";
          } else {
            if (empty) empty.style.display = "none";
            if (markers.length === 1) {
              try { map.setView(markers[0].getLatLng(), 4); } catch(e) {}
            } else if (markers.length > 1) {
              try {
                const group = L.featureGroup(markers);
                map.fitBounds(group.getBounds(), { maxZoom: 5, padding: [20, 20] });
              } catch(e) {}
            }
          }
        } catch(e) {
          console.error("Map update error", e);
        }
      }

      // Alerts and Logs
      function renderAlerts(list) {
        const node = document.getElementById("alertsList");
        node.innerHTML = "";
        if (!Array.isArray(list) || list.length === 0) return;

        list.forEach(a => {
          if (!a) return;
          const severity = a.severity || "info";
          const timeSec = typeof a.time === "number" ? a.time : Date.now() / 1000;
          const dt = new Date(timeSec * 1000);
          const badgeColor = severity === "error" ? "bg-red-500" : 
                           severity === "warn" ? "bg-yellow-400" : "bg-blue-400";

          const li = document.createElement("li");
          li.innerHTML = `<span class="badge ${badgeColor}">${severity.toUpperCase()}</span> <span class="text-xs text-gray-300">${dt.toLocaleTimeString()}</span> ‚Äî ${a.msg || ""}`;
          node.appendChild(li);
        });
      }

      function renderLogs(list) {
        const node = document.getElementById("logsList");
        node.innerHTML = "";
        if (!Array.isArray(list)) return;

        list.forEach(log => {
          if (!log) return;
          const dt = new Date(log.time * 1000).toLocaleTimeString();
          const color = log.level === "error" ? "text-red-400" :
                       log.level === "warn" ? "text-yellow-300" : "text-blue-300";

          const li = document.createElement("li");
          li.className = `mb-1 ${color}`;
          li.textContent = `[${dt}] [${log.level.toUpperCase()}] ${log.msg}`;
          node.appendChild(li);
        });
      }

      // Main data fetch and update function
      async function fetchData() {
        try {
          const res = await fetch("/data");
          const data = await res.json();

          // Update counters
          mechanicalCounter(document.getElementById("totalPackets"), data.total_packets, 1400, 12);
          document.getElementById("activeConnections").innerText = data.active_connections;
          
          // Update packet direction counters
          document.getElementById("packetsSent").innerText = formatNumber(data.packet_directions?.sent || 0);
          document.getElementById("packetsReceived").innerText = formatNumber(data.packet_directions?.received || 0);

          // Update existing charts
          if (protocolChart && data.protocols) {
            const protoLabels = Object.keys(data.protocols);
            protocolChart.data.labels = protoLabels;
            protocolChart.data.datasets[0].data = Object.values(data.protocols);
            protocolChart.data.datasets[0].backgroundColor = colorPalette.slice(0, protoLabels.length);
            protocolChart.update();
          }

          if (appProtocolChart && data.app_protocols) {
            const appProtoLabels = Object.keys(data.app_protocols);
            appProtocolChart.data.labels = appProtoLabels;
            appProtocolChart.data.datasets[0].data = Object.values(data.app_protocols);
            appProtocolChart.data.datasets[0].backgroundColor = colorPalette.slice(0, appProtoLabels.length);
            appProtocolChart.update();
          }

          if (appBandwidthChart && data.app_bandwidth) {
            const appNames = Object.keys(data.app_bandwidth).slice(0, 8);
            const appBwValues = appNames.map(name => data.app_bandwidth[name].total);
            appBandwidthChart.data.labels = appNames.map(name => name.length > 15 ? name.substring(0, 12) + '...' : name);
            appBandwidthChart.data.datasets[0].data = appBwValues;
            appBandwidthChart.update();
          }

          if (ipChart && data.top_ips) {
            ipChart.data.labels = data.top_ips.map(x => x[0] + " (" + x[1] + ")");
            ipChart.data.datasets[0].data = data.top_ips.map(x => x[1]);
            ipChart.update();
          }

          if (portChart && data.top_ports) {
            portChart.data.labels = data.top_ports.map(x => x[0]);
            portChart.data.datasets[0].data = data.top_ports.map(x => x[1]);
            portChart.update();
          }

          if (sizeChart && data.packet_sizes) {
            sizeChart.data.labels = data.packet_sizes.map(x => x[0]);
            sizeChart.data.datasets[0].data = data.packet_sizes.map(x => x[1]);
            sizeChart.update();
          }

          // Bandwidth chart update
          const bw = data.bandwidth || [];
          if (bandwidthChart) {
            if (!_bandwidthInitialized) {
              bandwidthChart.data.datasets[0].data = bw.slice();
              bandwidthChart.data.labels = bw.map((_, i) => i - bw.length + "s");
              bandwidthChart.update();
              _bandwidthInitialized = true;
            } else if (bw.length > 0) {
              const newest = bw[bw.length - 1];
              bandwidthChart.data.datasets[0].data.push(newest);
              while (bandwidthChart.data.datasets[0].data.length > bw.length) {
                bandwidthChart.data.datasets[0].data.shift();
              }
              const arr = bandwidthChart.data.datasets[0].data;
              bandwidthChart.data.labels = arr.map((_, i) => i - arr.length + "s");
              bandwidthChart.update();
            }
          }

          // Update enhanced visualizations
          updateTrafficFlows(data.traffic_flows);
          updateNetworkTopology(data.network_topology);
          updatePacketDetails(data.detailed_packets);
          
          // Update standard components
          renderAlerts(data.alerts);
          updateMap(data.geo_points);
          renderLogs(data.logs || []);

        } catch (e) {
          console.error("Fetch error:", e);
        }
        
        setTimeout(fetchData, 2000);
      }

      // Initialize everything
      createCharts();
      fetchData();

      // Handle window resize for topology
      window.addEventListener('resize', () => {
        if (networkSimulation) {
          const container = document.getElementById("networkTopology");
          const svg = d3.select(container).select("svg");
          if (!svg.empty()) {
            const width = container.clientWidth;
            const height = container.clientHeight;
            svg.attr("width", width).attr("height", height);
            networkSimulation.force("center", d3.forceCenter(width / 2, height / 2)).restart();
          }
        }
      });
    </script>
  </body>
</html>